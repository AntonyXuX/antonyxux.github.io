<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="test"><title>Leveldb源码解析第二篇【Meta Block】 | AntonyX</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Leveldb源码解析第二篇【Meta Block】</h1><a id="logo" href="/.">AntonyX</a><p class="description">Antony的博客</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Leveldb源码解析第二篇【Meta Block】</h1><div class="post-meta">Jun 1, 2017<span> | </span><span class="category"><a href="/categories/Leveldb源码解析/">Leveldb源码解析</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><blockquote>
<p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p>
</blockquote>
<p>上一章中详细讲解了 <code>table</code> 中的 <code>data block</code> 的结构以及涉及的源码，本章中将讲解 <code>table</code> 结构中的 <code>meta block</code></p>
<h4 id="table-结构"><a href="#table-结构" class="headerlink" title="table 结构"></a><code>table</code> 结构</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beginning_of_file</span>&gt;</span></div><div class="line">[data block 1]</div><div class="line">[data block 2]</div><div class="line">...</div><div class="line">[data block N]</div><div class="line">[meta block 1]</div><div class="line">...</div><div class="line">[meta block K]</div><div class="line">[metaindex block]</div><div class="line">[index block]</div><div class="line">[Footer]        (fixed size; starts at file_size - sizeof(Footer))</div><div class="line"><span class="tag">&lt;<span class="name">end_of_file</span>&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>先说说 <code>meta block</code> 在 <code>table</code> 中的作用</p>
</blockquote>
<p>一个meta block对应一个data block，meta block的作用是快速判断对应的data block中是否存在某个key，详情可以搜索“Bloom Filter”</p>
<p>原理是这样的，首先需要定义一个大的bitmap，实际就是一个字符串，bitmap中初始时每一位都是0，当往data block中添加key时，会根据这个key值算出一组hash值，hash值对bitmap位数取模后将bitmap中对应的位置设置为1；当需要查询data block中是否存在某个key时，只需通过这个key计算一组hash值，然后查看hash值在bitmap中对应的位置的值是否为1，只有有一个位置不为1，说明这个data block中不存在这个key</p>
<p>上面所说的算法中会存在hash冲突，如果bitmap中已经存了两个key</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">key1 计算出的位置为 [1,3]</div><div class="line">key2 计算出的位置为 [2,4]</div></pre></td></tr></table></figure>
<p>当我们要查询的 <code>key3</code> 计算出来的位置为[1,4]时，在 <code>bitmap</code> 中[1,4]两个位置都是1，这个只能说明data block中有可能存在key3，所以说bitmap是用来快速判断key不在data block中，我们需要做的是使出现误判的概率降到最低，可以得到一个公式</p>
<p>假设一个key要对应k个hash值，总共有n个key，bitmap的位数为m，那么出现误判的概率为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(1-(1-1/m)^(kn))^k</div></pre></td></tr></table></figure>
<p>上面的公式是怎么得到的呢？</p>
<p>假设我们现在要在bitmap中判断某个key是否存在，先要算出k个hash值，而这k个hash值对应的位置上面恰恰都有1的概率是多少呢</p>
<p>假设一个位置上面恰恰为1的概率为p，那么k个位置上面都为1的概率为p^k</p>
<p>p要怎么得到呢？</p>
<p>p代表的是一个位置上面恰恰为1的概率，我们可以先得到这个位置不为1的概率为q，那么，p=（1-q）</p>
<p>q要怎么得到呢？</p>
<p>q代表的是一个位置上面不为1的概率，说明n个key在计算k个hash的时候都没有落在这个点上，一次没有落在这个点上的概率为1-1/m，kn次没有落在这个点上的概率为(1-1/m)^(kn)，那么kn次落在这个点上的概率为1-(1-1/m)^(kn)，一共有k个点，k个点都是1的概率就为(1-(1-1/m)^(kn))^k</p>
<blockquote>
<p>好多年不搞数学，上面的公式解释的好痛苦（-_-!!!）</p>
</blockquote>
<p>为了保证误判的概率最低，如果m和n固定的话，可以得到k的最优解为k=m/n*ln2，我也不知道怎么算出来的，网上抄的（-_-!!!）</p>
<p>上面说了这么多理论，接下来要开始撸代码啦</p>
<blockquote>
<p>搞懂 <code>meta block</code> 需要阅读如下源码文件<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> table/filter_block.h             <span class="comment">// [非常重要|难度:4  级] filter_block的结构</span></div><div class="line"><span class="number">2</span> table/filter_block.cc</div><div class="line"></div><div class="line"><span class="number">3</span> include/leveldb/filter_policy.h       <span class="comment">// [重要|难度:2级] 过滤策略</span></div><div class="line"><span class="number">4</span> util/bloom.cc                         <span class="comment">// [重要|难度:2级] 过滤策略具体实现</span></div></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="filter-policy-h"><a href="#filter-policy-h" class="headerlink" title="filter_policy.h"></a>filter_policy.h</h4><p>先介绍 <code>filter_policy</code>，中文翻译为过滤策略，这个地方只是定义了一个接口，用户可以重写这个接口</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> FilterPolicy &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> ~FilterPolicy();</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;       <span class="comment">//返回当前策略的名字</span></div><div class="line"></div><div class="line">  <span class="comment">// dst就是上面讲的bitmap，n表示一个key在bitmap中占多少位，这个函数就是通过传进来的keys，来构建一个bitmap</span></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CreateFilter</span><span class="params">(<span class="keyword">const</span> Slice* keys, <span class="keyword">int</span> n, <span class="built_in">std</span>::<span class="built_in">string</span>* dst)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="comment">// bitmap中有没有key</span></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">KeyMayMatch</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; filter)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// Return a new filter policy that uses a bloom filter with approximately</span></div><div class="line"><span class="comment">// the specified number of bits per key.  A good value for bits_per_key</span></div><div class="line"><span class="comment">// is 10, which yields a filter with ~ 1% false positive rate.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Callers must delete the result after any database that is using the</span></div><div class="line"><span class="comment">// result has been closed.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Note: if you are using a custom comparator that ignores some parts</span></div><div class="line"><span class="comment">// of the keys being compared, you must not use NewBloomFilterPolicy()</span></div><div class="line"><span class="comment">// and must provide your own FilterPolicy that also ignores the</span></div><div class="line"><span class="comment">// corresponding parts of the keys.  For example, if the comparator</span></div><div class="line"><span class="comment">// ignores trailing spaces, it would be incorrect to use a</span></div><div class="line"><span class="comment">// FilterPolicy (like NewBloomFilterPolicy) that does not ignore</span></div><div class="line"><span class="comment">// trailing spaces in keys.</span></div><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">const</span> FilterPolicy* <span class="title">NewBloomFilterPolicy</span><span class="params">(<span class="keyword">int</span> bits_per_key)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="bloom-cc"><a href="#bloom-cc" class="headerlink" title="bloom.cc"></a>bloom.cc</h4><p><code>filter_policy</code> 的具体实现</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">class BloomFilterPolicy : public FilterPolicy &#123;</div><div class="line"> private:</div><div class="line">  size_t bits_per_key_;   // 前文中讲到的n/m，bitmap的位数除以key的个数</div><div class="line">  size_t k_;              // 前文中讲到的k，一个key在bitmap中要算出多少个hash</div><div class="line"></div><div class="line"> public:</div><div class="line">  explicit BloomFilterPolicy(int bits_per_key)</div><div class="line">      : bits_per_key_(bits_per_key) &#123;</div><div class="line">    // 构造方法，直接给bits_pre_key_赋值</div><div class="line">    // 根据前文讲到的k的最优解，k=n/m * ln2，ln2=~ 0.69，所以k的最优解为bits_per_key*0.69</div><div class="line">    // We intentionally round down to reduce probing cost a little bit</div><div class="line">    k_ = static_cast&lt;size_t&gt;(bits_per_key * 0.69);  // 0.69 =~ ln(2)</div><div class="line">    // k_肯定不能小于1，如果k_太大的话，每次计算hash会消耗计算资源，划不来，这个地方对误判率和计算资源做了权衡，k_最大为30</div><div class="line">    if (k_ &lt; 1) k_ = 1;</div><div class="line">    if (k_ &gt; 30) k_ = 30;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // 过滤策略的名称</div><div class="line">  virtual const char* Name() const &#123;</div><div class="line">    return "leveldb.BuiltinBloomFilter2";</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // dst就是上面讲的bitmap，n表示一个key在bitmap中占多少位，这个函数就是通过传进来的keys，来构建一个bitmap</div><div class="line">  virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const &#123;</div><div class="line">    // 计算出bitmap有多少位</div><div class="line">    size_t bits = n * bits_per_key_;</div><div class="line"></div><div class="line">    // For small n, we can see a very high false positive rate.  Fix it</div><div class="line">    // by enforcing a minimum bloom filter length.</div><div class="line">    // 如果n很小的话，误判率会很高，所以设置了一个最小值，64位，也就是8个字节</div><div class="line">    if (bits &lt; 64) bits = 64;</div><div class="line"></div><div class="line">    // 加上7然后除以8，只要不是整除，就会进一位</div><div class="line">    size_t bytes = (bits + 7) / 8;</div><div class="line">    // 算出实际的bitmap有多少位</div><div class="line">    bits = bytes * 8;</div><div class="line"></div><div class="line">    const size_t init_size = dst-&gt;size();</div><div class="line">    // 把bitmap放到dst后面，并用0填充，dst存放不止一个bitmap</div><div class="line">    dst-&gt;resize(init_size + bytes, 0);</div><div class="line">    // 将k_添加到dst的末尾，k_表示的是一个key算多少次hash</div><div class="line">    dst-&gt;push_back(static_cast&lt;char&gt;(k_));  // Remember # of probes in filter</div><div class="line">    // init_size是dst的初始长度，array指向当前bitmap的起始位置</div><div class="line">    char* array = &amp;(*dst)[init_size];</div><div class="line">    // 又到了划重点的时间，这个地方就是将key转为hash值，然后将bitmap对应的点这是为1</div><div class="line">    // n是key的个数</div><div class="line">    for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">      // Use double-hashing to generate a sequence of hash values.</div><div class="line">      // See analysis in [Kirsch,Mitzenmacher 2006].</div><div class="line">      // 关于bloomHash这里就不多解释了，有时间我会专门写一篇关于hash的文章</div><div class="line">      // 这里只需要知道BloomHash就是闯进去一个key，返回一个hash值，h就是返回的hash值</div><div class="line">      uint32_t h = BloomHash(keys[i]);</div><div class="line">      // (h &gt;&gt; 17) | (h &lt;&lt; 15) 这个和hash算法有关，通过一系列的位运算来随机种子</div><div class="line">      const uint32_t delta = (h &gt;&gt; 17) | (h &lt;&lt; 15);  // Rotate right 17 bits</div><div class="line">      // k_表示的是一个key算多少次hash，如果用BloomHash来算hash的话，计算量太大，这里用到了一个简单的方法</div><div class="line">      // 就是前几行中得到的随机种子再与h相加</div><div class="line">      for (size_t j = 0; j &lt; k_; j++) &#123;</div><div class="line">        // 得到要修改的位在第几个字节上</div><div class="line">        const uint32_t bitpos = h % bits;</div><div class="line">        // 取模 然后位移 再或上 定位到的字节</div><div class="line">        array[bitpos/8] |= (1 &lt;&lt; (bitpos % 8));</div><div class="line">        h += delta;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">// 判断bitmap中有没有key</div><div class="line">  virtual bool KeyMayMatch(const Slice&amp; key, const Slice&amp; bloom_filter) const &#123;</div><div class="line">    const size_t len = bloom_filter.size();</div><div class="line">    if (len &lt; 2) return false;</div><div class="line"></div><div class="line">    const char* array = bloom_filter.data();</div><div class="line">    // len-1是因为bitmap的最后一位存放的是k_，也就是一个key要计算多少次hash</div><div class="line">    const size_t bits = (len - 1) * 8;</div><div class="line"></div><div class="line">    // 得到最后一个自己里面存放的值</div><div class="line">    const size_t k = array[len-1];</div><div class="line">    if (k &gt; 30) &#123;</div><div class="line">      // k的计算方法是,k=m/n*ln2，m表示bitmap的位数，n表示key的个数，如果k大于30，说明key很少</div><div class="line">      // 既然key很少，遍历一遍data block也不会很耗资源</div><div class="line">      // 但是得到30多个hash的话就比较费资源了，那还不如认为当前data block中有可能有这个key</div><div class="line">      return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 下面的代码就和CreateFilter中的差不多了，只要找到一个hash值对应的点不为1，那就说明key在这个data block中不存在</div><div class="line">    uint32_t h = BloomHash(key);</div><div class="line">    const uint32_t delta = (h &gt;&gt; 17) | (h &lt;&lt; 15);  // Rotate right 17 bits</div><div class="line">    for (size_t j = 0; j &lt; k; j++) &#123;</div><div class="line">      const uint32_t bitpos = h % bits;</div><div class="line">      if ((array[bitpos/8] &amp; (1 &lt;&lt; (bitpos % 8))) == 0) return false;</div><div class="line">      h += delta;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 暂时还不知道有啥用，后面补充</div><div class="line">const FilterPolicy* NewBloomFilterPolicy(int bits_per_key) &#123;</div><div class="line">  return new BloomFilterPolicy(bits_per_key);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面介绍一下bloom的具体实现，现在来介绍在table中的filter block怎么构建了，这个地方的命名我个人觉得有点奇怪，block.h中介绍的是block的结构，真正来构建一个block的类是block_builder，而filter_block.h就是用来构建filter_block的</p>
<p>filter_block.h中有两个类，一个是构建一个filter_block的，还有一个是来解析filter_block的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// filter_block.h</span></div><div class="line"><span class="comment">// filter block构建类，一个FilterBlockBuilder对象并不是只存放一个</span></div><div class="line"><span class="keyword">class</span> FilterBlockBuilder &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">FilterBlockBuilder</span><span class="params">(<span class="keyword">const</span> FilterPolicy*)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">// 开始构建filter block</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">StartBlock</span><span class="params">(<span class="keyword">uint64_t</span> block_offset)</span></span>;</div><div class="line">  <span class="comment">// 在table添加key的时候，有一个地方会专门存放key，当一个data block完成时，就会用存储的key来构建filter block</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AddKey</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span></span>;</div><div class="line">  <span class="comment">// 当一个filter block构建完成后，还需要做一些处理</span></div><div class="line">  <span class="function">Slice <span class="title">Finish</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line"> <span class="comment">// 真正构建filter block的地方</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GenerateFilter</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">// 上面讲了那么多就是说的这个，里面有k_、bits_per_key_、filter block中是否存在key的方法和创建filter block的方法</span></div><div class="line">  <span class="keyword">const</span> FilterPolicy* policy_;</div><div class="line">  <span class="comment">// 把key通过追加的方式全部放在keys_中</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> keys_;              <span class="comment">// Flattened key contents</span></div><div class="line">  <span class="comment">// 存放了每个key的索引，和keys_一起用可以得到每个key</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; start_;     <span class="comment">// Starting index in keys_ of each key</span></div><div class="line">  <span class="comment">// 真正放bitmap的地方，table里面所有data block的bitmap全部都在这里面哟</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> result_;            <span class="comment">// Filter data computed so far</span></div><div class="line">  <span class="comment">// 临时存放keys的地方，后面会提到</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Slice&gt; tmp_keys_;   <span class="comment">// policy_-&gt;CreateFilter() argument</span></div><div class="line">  <span class="comment">// 和start_类似，用来存放每个bitmap的索引，其实就是在result_中的起始地址，和result一起使用可以得到具体的bitmap</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint32_t</span>&gt; filter_offsets_;</div><div class="line"></div><div class="line">  <span class="comment">// 只允许引用，不允许隐式构造</span></div><div class="line">  FilterBlockBuilder(<span class="keyword">const</span> FilterBlockBuilder&amp;);</div><div class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> FilterBlockBuilder&amp;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// filter block解析类</span></div><div class="line"><span class="keyword">class</span> FilterBlockReader &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line"> <span class="comment">// REQUIRES: "contents" and *policy must stay live while *this is live.</span></div><div class="line">  FilterBlockReader(<span class="keyword">const</span> FilterPolicy* policy, <span class="keyword">const</span> Slice&amp; contents);</div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">KeyMayMatch</span><span class="params">(<span class="keyword">uint64_t</span> block_offset, <span class="keyword">const</span> Slice&amp; key)</span></span>;</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> FilterPolicy* policy_;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* data_;    <span class="comment">// Pointer to filter data (at block-start)</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* offset_;  <span class="comment">// Pointer to beginning of offset array (at block-end)</span></div><div class="line">  <span class="keyword">size_t</span> num_;          <span class="comment">// Number of entries in offset array</span></div><div class="line">  <span class="keyword">size_t</span> base_lg_;      <span class="comment">// Encoding parameter (see kFilterBaseLg in .cc file)</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// filter_block.cc</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kFilterBaseLg = <span class="number">11</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kFilterBase = <span class="number">1</span> &lt;&lt; kFilterBaseLg;</div><div class="line"></div><div class="line"><span class="comment">// 构造方法，policy_里面有k_、bits_per_key_、filter block中是否存在key的方法和创建filter block的方法</span></div><div class="line">FilterBlockBuilder::FilterBlockBuilder(<span class="keyword">const</span> FilterPolicy* policy)</div><div class="line">    : policy_(policy) &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 开始构建filter block，上一章我理解错了，不是一个data block构建一个filter block，而是2k的数据构建一个filter block</span></div><div class="line"><span class="comment">/* </span></div><div class="line">如果这一块的逻辑让我来写的话，逻辑应该是这样的</div><div class="line">当一个data block构建完成后，调用StartBlock方法，分配一个的bitmap，</div><div class="line">通过policy_里面的CreateFilter方法将这个data block里面的keys转换成bitmap的对应的位；</div><div class="line">上面的是写入bitmap，怎么读取这个bitmap呢？</div><div class="line">一个data block对应一个bitmap，如果要读bitmap，就需要知道table中bitmap对应的是第k个data block</div><div class="line">当遍历table里面的data block时，就需要记录k值</div><div class="line">然后得到第k个bitmap</div><div class="line">*/</div><div class="line"><span class="comment">/*</span></div><div class="line">上面是我个人的逻辑，再看看大神的逻辑</div><div class="line">上面我们是通过得到是第k个data block从而得到bitmap</div><div class="line">大神的方法通过data block在table中的偏移量来得到是第几个bitmap，方法如下</div><div class="line">直观上理解是每2k的data block就分配一个bitmap，通过data block的偏移量，然后除以2，就可以得到是第几个bitmap了</div><div class="line">那问题了，data block的大小阈值是2k，但并不是说data block大小就是2k，如果data block中存放了一个7k的key-value,</div><div class="line">那在得到bitmap的时候怎么将这个data block分成多个2k呢？</div><div class="line">【这里我们补充一个变量filter_offsets_，它是用来存放每个bitmap的偏移量，如果要得到第n个bitmap，</div><div class="line">只需filter_offsets_[n]，得到第n个bitmap的偏移，然后result_+filter_offsets_[n]，就可以得到bitmap了】</div><div class="line">还是上面7k的例子，如果除以2，需要分配3个bitmap，实际上第一个bitmap就是这个data block的索引了</div><div class="line">那剩下的两个bitmap呢？剩下的两个bitmap是空的，这两个bitmap在filter_offsets_中指向的还是第一个bitmap的位置</div><div class="line">相当于在filter_offsets_中占了两个位置，实际存放bitmap的result_啥也没存</div><div class="line">如果第1个data block大小是7k，第2个data block大小是5k</div><div class="line">那么第1个data block在table中的偏移量为7，7/2=3,在filter_offsets_中会有3条记录，不过存放的都是第一个bitmap的偏移</div><div class="line">第2个data block在table中的偏移量为12，12/2=5,在filter_offsets_中会加2条记录，2条记录存放的都是第二个bitmap的偏移</div><div class="line">现在得到第1个data block的bitmap，偏移量/2=3，filter_offsets_的第3条记录指向的是第1个bitmap的偏移，获取成功</div><div class="line">得到第2个data block的bitmap，偏移量/2=5，filter_offsets_的第5条记录指向的是第2个bitmap的偏移，获取成功</div><div class="line">*/</div><div class="line"><span class="keyword">void</span> FilterBlockBuilder::StartBlock(<span class="keyword">uint64_t</span> block_offset) &#123;</div><div class="line"><span class="comment">// filter_index bitmap索引个数</span></div><div class="line"><span class="keyword">uint64_t</span> filter_index = (block_offset / kFilterBase);</div><div class="line">assert(filter_index &gt;= filter_offsets_.size());</div><div class="line"><span class="comment">// 只要bitmap索引个数比当前索引个数大，就一直构建filter block，实际只有第一次循环的时候在result_中放了一个bitmap</span></div><div class="line"><span class="comment">// 其他循环都只是在filter_offsets_中存放第一次循环中得到的bitmap的偏移</span></div><div class="line">  <span class="keyword">while</span> (filter_index &gt; filter_offsets_.size()) &#123;</div><div class="line">    GenerateFilter();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 将key放在keys_中，将key的大小放在start_中，构建filter data的时候用到</span></div><div class="line"><span class="keyword">void</span> FilterBlockBuilder::AddKey(<span class="keyword">const</span> Slice&amp; key) &#123;</div><div class="line">  Slice k = key;</div><div class="line">  start_.push_back(keys_.size());</div><div class="line">  keys_.append(k.data(), k.size());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// finish是在table构建时调用的</span></div><div class="line">Slice FilterBlockBuilder::Finish() &#123;</div><div class="line">  <span class="keyword">if</span> (!start_.empty()) &#123;</div><div class="line">    GenerateFilter();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Append array of per-filter offsets</span></div><div class="line">  <span class="comment">// 当所有bitmap全部构建完成后，将所有的偏移量放到result_中</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> array_offset = result_.size();</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; filter_offsets_.size(); i++) &#123;</div><div class="line">    PutFixed32(&amp;result_, filter_offsets_[i]);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 最后再将所有bitmap的大小放到result_的后面</span></div><div class="line">  PutFixed32(&amp;result_, array_offset);</div><div class="line">  <span class="comment">// 将 2k 这个数字放在最后</span></div><div class="line">  <span class="comment">// 那么在解析result_的时候，读取最后一个字节，表示data block按多少k分割</span></div><div class="line">  <span class="comment">// 读取倒数第5到倒数第2个字节（size），表示所有bitmap的大小</span></div><div class="line">  <span class="comment">// result_+size就可以字节偏移到记录偏移点的地方，这有就可以一步一步解析了</span></div><div class="line">  result_.push_back(kFilterBaseLg);  <span class="comment">// Save encoding parameter in result</span></div><div class="line">  </div><div class="line">  <span class="keyword">return</span> Slice(result_);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 划重点</span></div><div class="line"><span class="keyword">void</span> FilterBlockBuilder::GenerateFilter() &#123;</div><div class="line">  <span class="comment">// 得到当前block中key的个数</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> num_keys = start_.size();</div><div class="line">  <span class="comment">// 如果没有key，说明之前已经创建过bitmap了，现在只需要把当前偏移量放到filter_offsets_中</span></div><div class="line">  <span class="keyword">if</span> (num_keys == <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// Fast path if there are no keys for this filter</span></div><div class="line">    filter_offsets_.push_back(result_.size());</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Make list of keys from flattened key structure</span></div><div class="line">  <span class="comment">// start_存放的是所有key的起始位置，下面一步是把结束的位置也放进去</span></div><div class="line">  start_.push_back(keys_.size());  <span class="comment">// Simplify length computation</span></div><div class="line">  <span class="comment">// tmp_keys_上面再定义的时候没有解释，这里详细解释，就是用来存放当前data block中的key的，不过是以slice的形式存储的</span></div><div class="line">  tmp_keys_.resize(num_keys);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; num_keys; i++) &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* base = keys_.data() + start_[i];</div><div class="line">    <span class="keyword">size_t</span> length = start_[i+<span class="number">1</span>] - start_[i];</div><div class="line">    tmp_keys_[i] = Slice(base, length);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Generate filter for current set of keys and append to result_.</span></div><div class="line">  <span class="comment">// 记录result_的大小，实际是记录下一个filter block的起始位置</span></div><div class="line">  filter_offsets_.push_back(result_.size());</div><div class="line">  <span class="comment">// 得到filter block后放在result_里面</span></div><div class="line">  policy_-&gt;CreateFilter(&amp;tmp_keys_[<span class="number">0</span>], <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(num_keys), &amp;result_);</div><div class="line"></div><div class="line">  tmp_keys_.clear();</div><div class="line">  keys_.clear();</div><div class="line">  start_.clear();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 下面就是filter  block的解析过程了</span></div><div class="line">FilterBlockReader::FilterBlockReader(<span class="keyword">const</span> FilterPolicy* policy,</div><div class="line">                                     <span class="keyword">const</span> Slice&amp; contents)</div><div class="line">    : policy_(policy),</div><div class="line">      data_(<span class="literal">NULL</span>),</div><div class="line">      offset_(<span class="literal">NULL</span>),</div><div class="line">      num_(<span class="number">0</span>),</div><div class="line">      base_lg_(<span class="number">0</span>) &#123;</div><div class="line">  <span class="keyword">size_t</span> n = contents.size();</div><div class="line">  <span class="comment">// contents的大小不可能小于5，最后一个字节记录kFilterBaseLg，然后4个字节记录所有bitmap的大小</span></div><div class="line">  <span class="keyword">if</span> (n &lt; <span class="number">5</span>) <span class="keyword">return</span>;  <span class="comment">// 1 byte for base_lg_ and 4 for start of offset array</span></div><div class="line">  <span class="comment">// 这个在上面说过，最后一个字节是kFilterBaseLg</span></div><div class="line">  base_lg_ = contents[n<span class="number">-1</span>];</div><div class="line">  <span class="comment">// 然后得到倒数第5到倒数第2个字节，转为uint32，就可以得到所有bitmap的大小</span></div><div class="line">  <span class="keyword">uint32_t</span> last_word = DecodeFixed32(contents.data() + n - <span class="number">5</span>);</div><div class="line">  <span class="keyword">if</span> (last_word &gt; n - <span class="number">5</span>) <span class="keyword">return</span>;</div><div class="line">  data_ = contents.data();</div><div class="line">  <span class="comment">// offset_就是记录偏移量的位置了</span></div><div class="line">  offset_ = data_ + last_word;</div><div class="line">  <span class="comment">// num_记录有多少个偏移量，总大小减去最后5个字节，然后再减去bitmap的大小，剩下的就全是记录偏移量了</span></div><div class="line">  <span class="comment">// 一个偏移量占4个字节，(n - 5 - last_word) / 4 就表示有多少个偏移量了</span></div><div class="line">  num_ = (n - <span class="number">5</span> - last_word) / <span class="number">4</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 通过block的偏移量来判断 key 在不在这个block中</span></div><div class="line"><span class="keyword">bool</span> FilterBlockReader::KeyMayMatch(<span class="keyword">uint64_t</span> block_offset, <span class="keyword">const</span> Slice&amp; key) &#123;</div><div class="line">  <span class="comment">// block_offset 往右移11位，意思就是除以2k，也就是得到是第几个bitmap</span></div><div class="line">  <span class="keyword">uint64_t</span> index = block_offset &gt;&gt; base_lg_;</div><div class="line">  <span class="keyword">if</span> (index &lt; num_) &#123;</div><div class="line">    <span class="comment">// 然后再通过bitmap的偏移量得到真正的bitmap</span></div><div class="line">    <span class="keyword">uint32_t</span> start = DecodeFixed32(offset_ + index*<span class="number">4</span>);</div><div class="line">    <span class="keyword">uint32_t</span> limit = DecodeFixed32(offset_ + index*<span class="number">4</span> + <span class="number">4</span>);</div><div class="line">    <span class="keyword">if</span> (start &lt;= limit &amp;&amp; limit &lt;= <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(offset_ - data_)) &#123;</div><div class="line">      Slice filter = Slice(data_ + start, limit - start);</div><div class="line">      <span class="comment">// 判断bitmap中有没有key</span></div><div class="line">      <span class="keyword">return</span> policy_-&gt;KeyMayMatch(key, filter);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start == limit) &#123;</div><div class="line">      <span class="comment">// Empty filters do not match any keys</span></div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// Errors are treated as potential matches</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>【作者：antonyxu   <a href="https://antonyxux.github.io/】">https://antonyxux.github.io/】</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://antonyxux.github.io/2017/06/01/leveldb-2/" data-id="cj3j1kkap0002ezx8clhgbvna" class="article-share-link">分享</a><div class="tags"><a href="/tags/leveldb/">leveldb</a><a href="/tags/C/">C++</a></div><div class="post-nav"><a href="/2017/06/02/leveldb-3/" class="pre">Leveldb源码解析第三篇【Table 收尾】</a><a href="/2017/05/30/leveldb-1/" class="next">Leveldb源码解析第一篇【Data Block】</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://antonyxux.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Leveldb源码解析/">Leveldb源码解析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/leveldb/" style="font-size: 15px;">leveldb</a> <a href="/tags/C/" style="font-size: 15px;">C++</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/06/04/leveldb-4/">Leveldb源码解析第四篇【table添加key的流程】</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/02/leveldb-3/">Leveldb源码解析第三篇【Table 收尾】</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/01/leveldb-2/">Leveldb源码解析第二篇【Meta Block】</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/30/leveldb-1/">Leveldb源码解析第一篇【Data Block】</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://antonyxux.github.io/" title="链接出租" target="_blank">链接出租</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">AntonyX.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>