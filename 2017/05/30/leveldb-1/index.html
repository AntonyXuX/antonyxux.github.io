<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="test"><title>Leveldb源码解析第一篇【Data Block】 | AntonyX</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Leveldb源码解析第一篇【Data Block】</h1><a id="logo" href="/.">AntonyX</a><p class="description">Antony的博客</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Leveldb源码解析第一篇【Data Block】</h1><div class="post-meta">May 30, 2017<span> | </span><span class="category"><a href="/categories/Leveldb源码解析/">Leveldb源码解析</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><blockquote>
<p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p>
</blockquote>
<p><code>leveldb</code> 作为一个 <code>key-value</code> 数据库，它和 <code>redis</code> 的区别在于不仅没有把所有的数据放在内存中，而是把大部分数据放在了磁盘中</p>
<h4 id="leveldb-存数据的流程"><a href="#leveldb-存数据的流程" class="headerlink" title="leveldb 存数据的流程"></a><code>leveldb</code> 存数据的流程</h4><ol>
<li>先指定一块内存写数据（这块内存称为 <code>MemTable</code>），当占用的内存高于阈值后，将这块内存转为只读（这块只读内存称为 <code>Immutable MemTable</code>）</li>
<li>同时开辟一块新的内存（ <code>MemTable</code>）来写数据</li>
<li>然后异步将 <code>Immutable MemTable</code> 的数据添加到存到磁盘中</li>
</ol>
<p>本文将从数据怎么写入磁盘开始讲起（第 <code>3</code> 步中的数据存储到磁盘），数据写入磁盘时会先将数据放在一个名叫 <code>table</code> 的结构中，<code>table</code> 中包含有很多个 <code>block</code>，<code>block</code> 是真正用来存储 <code>key-value</code> 的<br>当 <code>table</code> 的大小大于指定阈值时，就会把 <code>table</code> 中的数据写入到磁盘中</p>
<h4 id="table-结构"><a href="#table-结构" class="headerlink" title="table 结构"></a><code>table</code> 结构</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beginning_of_file</span>&gt;</span></div><div class="line">[data block 1]</div><div class="line">[data block 2]</div><div class="line">...</div><div class="line">[data block N]</div><div class="line">[meta block 1]</div><div class="line">...</div><div class="line">[meta block K]</div><div class="line">[metaindex block]</div><div class="line">[index block]</div><div class="line">[Footer]        (fixed size; starts at file_size - sizeof(Footer))</div><div class="line"><span class="tag">&lt;<span class="name">end_of_file</span>&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>第一眼看着不明觉厉，这是个什么鬼玩意呢</p>
</blockquote>
<p>其实 <code>table</code> 就是用来存放多个 <code>data block</code> 的，那问题来了，下面一堆 <code>meta block</code> / <code>metaindex block</code> / <code>index block</code> 是什么鬼？</p>
<blockquote>
<p>当我们在 <code>table</code> 里面查询一个 <code>key</code>，在没有索引的情况下，就需要将所有的 <code>data block</code> 遍历一遍，如果按照这种方式找的话，十亿级的数据存储找到猴年马月才能找到，怎样才能<strong>高效</strong>的找到我们需要查询的 <code>key</code> 呢，就靠上面所说的那堆鬼东西，这里我们按下不表，后面会详细介绍（挖坑1）</p>
</blockquote>
<p><strong>上面说了这么多，只是为了让大家有个基本的概念，本章重点要讲解的是 <code>table</code> 中 <code>data block</code></strong></p>
<h3 id="data-block"><a href="#data-block" class="headerlink" title="data block"></a>data block</h3><p>万丈高楼平地起，我们现在来介绍 <code>Leveldb</code> 中最基础的结构，也是真正存储 <code>KV</code> 的结构 <code>data block</code></p>
<blockquote>
<p>搞懂 <code>data block</code> 需要阅读如下源码文件</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> table/block.h             <span class="comment">// [非常重要|难度:3级] block的结构</span></div><div class="line"><span class="number">2</span> table/block.cc</div><div class="line"><span class="number">3</span> table/block_build.h       <span class="comment">// [非常重要|难度:3级] 用于构建 block</span></div><div class="line"><span class="number">4</span> table/block_build.cc</div><div class="line"><span class="number">5</span> include/leveldb/slice.h   <span class="comment">// [非常重要|难度:1级] leveldb 中用到的 string 都封装成了 slice </span></div><div class="line"><span class="number">6</span> util/coding.h             <span class="comment">// [非常重要|难度:2级] 类型转换，编码转换</span></div><div class="line"><span class="number">7</span> util/coding.cc</div></pre></td></tr></table></figure>
<h4 id="slice-h-（简单了解后可跳过）"><a href="#slice-h-（简单了解后可跳过）" class="headerlink" title="slice.h （简单了解后可跳过）"></a>slice.h （简单了解后可跳过）</h4><p>先介绍最简单的 <code>slice</code>，实际就是把 <code>string</code> 封装了一下，它拥有两个私有变量和几个简单的处理函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>:</div><div class="line"> <span class="keyword">char</span> <span class="keyword">operator</span>[](<span class="keyword">size_t</span> n) <span class="keyword">const</span>;  <span class="comment">// 符号重载[]，返回第n个字符</span></div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">remove_prefix</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>;     <span class="comment">// 删除前n个字符</span></div><div class="line"> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">ToString</span><span class="params">()</span></span>;           <span class="comment">// 转成string</span></div><div class="line"> <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Slice&amp; b)</span></span>;      <span class="comment">// 比较字符串大小</span></div><div class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">starts_with</span><span class="params">(<span class="keyword">const</span> Slice&amp; x)</span></span>; <span class="comment">// 将this.data_前面x.size_个字符替换成x.data_</span></div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line"> <span class="keyword">const</span> <span class="keyword">char</span>* data_;    <span class="comment">// 存储字符串</span></div><div class="line"> <span class="keyword">size_t</span> size_;         <span class="comment">// 记录data_的长度</span></div></pre></td></tr></table></figure>
<blockquote>
<p>涉及的小知识  （专为像我这样的新手准备，请看 【Leveldb源码解析新手补充篇】）</p>
<ul>
<li>符号重载</li>
<li><code>size_t</code> 类型</li>
<li><code>inline</code> 内联函数</li>
<li>函数后面 <code>const</code> 有啥作用</li>
</ul>
</blockquote>
<h4 id="coding-h-和-coding-cc"><a href="#coding-h-和-coding-cc" class="headerlink" title="coding.h 和 coding.cc"></a>coding.h 和 coding.cc</h4><p><code>coding</code> 这个类是用来类型转换和压缩空间的，比如声明一个 <code>uint32</code>，我们要分配4个字节的空间，如果这个 <code>uint32</code> 只是存储数字 <code>1</code>，那就太浪费了，一个字节就能搞定，浪费 <code>3</code> 个字节，而 <code>Leveldb</code> 中记录长度的 <code>uint</code> 变量非常多，不压缩的话就会浪费大量的空间</p>
<blockquote>
<p>这里只贴在 <code>data block</code> 部分中用到的两个函数，更多关于 <code>coding</code> 类的源码分析请看 【Leveldb源码解析工具篇之coding类】</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// coding.h</span></div><div class="line"><span class="comment">// 将 char* 转换为 uint32_t</span></div><div class="line"><span class="function"><span class="keyword">inline</span> uint32_t <span class="title">DecodeFixed32</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ptr)</span> </span>&#123;</div><div class="line"><span class="comment">/* 大小端模式，不同机器内存中存储字节的方式不同，这里有两个概念，高/低地址和高/低字节，举个栗子：如果我们要存储 0x12345678</span></div><div class="line">   高/低字节：从高位到低位的字节依次是0x12、0x34、0x56和0x78</div><div class="line">   高/低地址：大端模式 高位高地址，低位低地址；小端模式 低位高地址，高位低地址</div><div class="line">   大端模式：高地址 0x78|0x56|0x34|0x12 低地址</div><div class="line">   小端模式：高地址 0x12|0x34|0x56|0x78 低地址 */</div><div class="line"><span class="comment">// 在Leveldb中不管是什么模式存储，全部转为小端模式</span></div><div class="line">  <span class="keyword">if</span> (port::kLittleEndian) &#123;</div><div class="line">    <span class="comment">// Load the raw bytes</span></div><div class="line">    <span class="keyword">uint32_t</span> result;</div><div class="line">    <span class="comment">// 小端模式不用说，直接存即可</span></div><div class="line">    <span class="built_in">memcpy</span>(&amp;result, ptr, <span class="keyword">sizeof</span>(result));  <span class="comment">// 32位的int占几个字节就将ptr的几个字节拷贝到result中，直接写4不就好了吗？</span></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 大端模式就要转一下了，低位的换到高位，高位的换到低位，因为是转成uint_32_t，所以只有4个字节</span></div><div class="line">    <span class="comment">// 也就是将 0x78563412 转为 0x12345678，(0x78|0x56 &lt;&lt; 8|0x34 &lt;&lt; 16|0x12 &lt;&lt; 24)</span></div><div class="line">    <span class="keyword">return</span> ((<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(ptr[<span class="number">0</span>])))</div><div class="line">        | (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(ptr[<span class="number">1</span>])) &lt;&lt; <span class="number">8</span>)</div><div class="line">        | (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(ptr[<span class="number">2</span>])) &lt;&lt; <span class="number">16</span>)</div><div class="line">        | (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(ptr[<span class="number">3</span>])) &lt;&lt; <span class="number">24</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将数字v重新编码，然后放到dst中</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PutVarint32</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst, <span class="keyword">uint32_t</span> v)</span> </span>&#123;</div><div class="line">  <span class="keyword">char</span> buf[<span class="number">5</span>];      <span class="comment">// 这里为啥是5呢，请看 EncodeVarint32函数</span></div><div class="line">  <span class="comment">// 重新编码 v</span></div><div class="line">  <span class="keyword">char</span>* ptr = EncodeVarint32(buf, v);</div><div class="line">  <span class="comment">// 将重新编码后的 v 放到 dst 中</span></div><div class="line">  dst-&gt;append(buf, ptr - buf);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 编码的具体实现，看着有点花眼，其实挺有意思的，耐心往下看，会有种脑洞大开的感觉，这么神奇的办法他们是怎么想到的</span></div><div class="line">   编码的目的是为将int存储小数字时所浪费的空间节省下来，有可能节省1个字节，有可能节省2个字节，也有可能节省3个字节</div><div class="line">   节省的空间不同，int编码后占用的空间也就不固定了</div><div class="line">   如果直接将int放在string中，那么在string中解析这个int时只需读取4个字节，然后再转成int就是我们所要的int值</div><div class="line">   我们为什么知道这地方要读取4个字节，因为一个int占4个字节，读取4个字节这个int就结束了</div><div class="line">   但是编码后的int大小不固定，在string中解析编码后的int，怎么知道要读几个字节</div><div class="line">   一个字节是8位，大神将一个字节分为两个部分，最高位和低7位，低7位用来存数据，最高位用来表示有没有结束，举个栗子</div><div class="line">   值为300的int变量，二进制为0x100101100，在内存中实际只用两个字节，浪费两个字节</div><div class="line">   在内存中是这么存的           |0|0|0|0|0|0|0|1| 0|0|1|0|1|1|0|0|</div><div class="line">   而编码后在内存中是这么存的    |0|0|0|0|0|0|1|0| 1|0|1|0|1|1|0|0|</div><div class="line">   区别在哪儿呢，就是在第8位中插入一位，设置为1，为什么要怎么做</div><div class="line">   我们上面有讲，一个字节中7位用来存数据，1位表示是否结束，当我们读到一个字节时，判断最高位是否为1</div><div class="line">   如果是1，说明编码后的int还没有结束，需要继续读下一个字节，直到读到字节的最高位为0为止</div><div class="line">   PutVarint32 中定义的char数组长度为啥是5呢，在编码过程中，每个字节会拿出1bit来存储于是否结束标识</div><div class="line">   如果有一个int变量的值本身就占据4个字节，再加上每个字节最高位来存储结束标识，4个字节肯定是不够的，所以定义长度为5的字符数组来存储编码后的int</div><div class="line">*/ </div><div class="line"><span class="function"><span class="keyword">char</span>* <span class="title">EncodeVarint32</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint32_t</span> v)</span> </span>&#123;</div><div class="line">  <span class="comment">// 将 char* 强转为 unsigned char*，这里有个疑问，为啥不直接定义成unsigned char*？</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>* ptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>*&gt;(dst);</div><div class="line">  <span class="comment">// 128是不是有点眼熟呀，2的7次方，二进制写法为0x10000000</span></div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">128</span>;</div><div class="line">  <span class="keyword">if</span> (v &lt; (<span class="number">1</span>&lt;&lt;<span class="number">7</span>)) &#123;                 <span class="comment">// v小于128，说明7bit能存储，那么一个字节就能搞定，将ptr赋值为v，返回ptr的下一个地址</span></div><div class="line">    *(ptr++) = v;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span>&lt;&lt;<span class="number">14</span>)) &#123;         <span class="comment">// 如果v小于(1&lt;&lt;14)，说明要两个字节来存储</span></div><div class="line">    *(ptr++) = v | B;               <span class="comment">// v|B是将v的第8位设置为1，然后赋值给ptr，这里只会赋值一个字节</span></div><div class="line">    *(ptr++) = v&gt;&gt;<span class="number">7</span>;                <span class="comment">// 将v右移7位，实际上是为了得到第二个字节，下面的以此类推</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span>&lt;&lt;<span class="number">21</span>)) &#123;</div><div class="line">    *(ptr++) = v | B;</div><div class="line">    *(ptr++) = (v&gt;&gt;<span class="number">7</span>) | B;</div><div class="line">    *(ptr++) = v&gt;&gt;<span class="number">14</span>;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span>&lt;&lt;<span class="number">28</span>)) &#123;</div><div class="line">    *(ptr++) = v | B;</div><div class="line">    *(ptr++) = (v&gt;&gt;<span class="number">7</span>) | B;</div><div class="line">    *(ptr++) = (v&gt;&gt;<span class="number">14</span>) | B;</div><div class="line">    *(ptr++) = v&gt;&gt;<span class="number">21</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    *(ptr++) = v | B;</div><div class="line">    *(ptr++) = (v&gt;&gt;<span class="number">7</span>) | B;</div><div class="line">    *(ptr++) = (v&gt;&gt;<span class="number">14</span>) | B;</div><div class="line">    *(ptr++) = (v&gt;&gt;<span class="number">21</span>) | B;</div><div class="line">    *(ptr++) = v&gt;&gt;<span class="number">28</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(ptr);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>涉及的小知识  （专为像我这样的新手准备，请看 【Leveldb源码解析新手补充篇】）</p>
<ul>
<li>指针类型转换</li>
</ul>
</blockquote>
<h4 id="block"><a href="#block" class="headerlink" title="block"></a>block</h4><p>上面讲解了一下在 <code>block</code> 中用的工具类，现在开始进入主题，介绍一下 <code>block</code> 的结构（<code>table</code> 和 <code>block</code> 的结构一定要牢牢记住了）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[K-V Record 0] &lt;------------------</div><div class="line">[K-V Record 1]                   |</div><div class="line">...                              |</div><div class="line">[K-V Record 16] &lt;--------        |</div><div class="line">[K-V Record 17]         |        |</div><div class="line">...                     |        |</div><div class="line">[K-V Record n-1]        |        |</div><div class="line">[restart point 0]-------|--------|</div><div class="line">[restart point 1]-------|</div><div class="line">...</div><div class="line">[restart point (n+15)/16]</div><div class="line">[restart point number]</div></pre></td></tr></table></figure></p>
<ul>
<li><p><code>K-V Record</code> 里面存储的是 <code>key value</code> 值，在 <code>block</code> 中存储的 <code>key-value</code> 是顺序存储的，所以会出现多个连续的 <code>key</code> 有部分前缀是相同的，<code>leveldb</code> 为了压缩存储，会压缩前缀（具体请往后看），一行记录在 <code>block</code> 具体存储格式为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[key中相同部分大小][key中不同部分大小][value大小][key中不同部分值][value值]</div></pre></td></tr></table></figure>
</li>
<li><p><code>restart point</code> 在前缀压缩时，只记录了 <code>key</code> 中不同部分的数据，相同部分的数据需要从上一个 <code>key</code> 中获取，如果要获取第100个 <code>key</code> ，那么就需要把前 <code>99</code> 个 <code>key</code> 全部遍历出来，这样做的话会使查找 <code>key</code> 时效率很低，<code>leveldb</code> 的做法是相邻的 <code>16</code> 个 <code>key</code> 做一次前缀压缩，<code>restart point</code> 就是记录每 <code>16</code> 个 <code>key</code> 中第一个 <code>key</code> 的偏移量，举个栗子</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">0  [key中相同部分大小][key中不同部分大小][value大小][key中不同部分值][value值]</div><div class="line">1  [key中相同部分大小][key中不同部分大小][value大小][key中不同部分值][value值]</div><div class="line">2  [key中相同部分大小][key中不同部分大小][value大小][key中不同部分值][value值]</div><div class="line">...</div><div class="line">16 [key中相同部分大小][key中不同部分大小][value大小][key中不同部分值][value值]</div><div class="line">17 [key中相同部分大小][key中不同部分大小][value大小][key中不同部分值][value值]</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这里有 <code>18</code> 行记录，假如存储数据如下：（中间记录忽略）<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">第0行   [helloantony : antonyvalue]</div><div class="line">第1行   [helloatom   : atomvalue  ]</div><div class="line">第2行   [helloboy    : boyvalue   ]</div><div class="line">...</div><div class="line">第16行  [worldantony : antonyvalue]</div><div class="line">第17行  [worldatom   : atomvalue  ]</div></pre></td></tr></table></figure></p>
<p>在 <code>data block</code> 中真正存储的情况如下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[0][11][11][helloantony][antonyvalue]</div><div class="line">[6][ 3][ 9][tom][atomvalue]</div><div class="line">[5][ 3][ 8][boy][boyvalue]</div><div class="line">...</div><div class="line">[0][11][11][worldantony][antonyvalue]</div><div class="line">[6][ 3][ 9][tom][atomvalue]</div></pre></td></tr></table></figure></p>
<p>我们会看到第 <code>0</code> 行和第 <code>16</code> 行的 <code>key</code> 是完整保存的，这两行也是重启点所指向的点，为了方便理解，上面的结构中一条记录用一行显示，但实际存储中这些记录都是存储在一个长字符串中，重启点记录的是第 <code>0</code> 行和第 <code>16</code> 行在字符串中的偏移量，通过这些偏移就能能快速定位到这两个点，可以理解为索引</p>
<blockquote>
<p>重启点记录的偏移量怎么计算会在代码中详细讲解（挖坑2）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// block.h</span></div><div class="line"><span class="keyword">class</span> Block &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="comment">// Initialize the block with the specified contents.</span></div><div class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Block</span><span class="params">(<span class="keyword">const</span> BlockContents&amp; contents)</span></span>;    <span class="comment">// 构造方法，explicit关键字是不允许隐式构造，具体请看新手篇</span></div><div class="line"></div><div class="line">  ~Block();</div><div class="line"></div><div class="line">  <span class="keyword">size_t</span> size() <span class="keyword">const</span> &#123; <span class="keyword">return</span> size_; &#125;</div><div class="line">  <span class="function">Iterator* <span class="title">NewIterator</span><span class="params">(<span class="keyword">const</span> Comparator* comparator)</span></span>;  <span class="comment">// 返回一个迭代器，后面详细介绍</span></div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keyword">uint32_t</span> NumRestarts() <span class="keyword">const</span>;    <span class="comment">// 返回重启点个数</span></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* data_;               <span class="comment">// 这个就是我们上面说的长字符串</span></div><div class="line">  <span class="keyword">size_t</span> size_;                    <span class="comment">// block大小，占据多少个字节</span></div><div class="line">  <span class="keyword">uint32_t</span> restart_offset_;        <span class="comment">// 第一个restart point在data_中的偏移量</span></div><div class="line">  <span class="keyword">bool</span> owned_;                     <span class="comment">// data_是不是堆分配的内存，如果是的话就需要手动回收</span></div><div class="line"></div><div class="line">  <span class="comment">// No copying allowed</span></div><div class="line">  Block(<span class="keyword">const</span> Block&amp;);</div><div class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Block&amp;);</div><div class="line"></div><div class="line">  <span class="keyword">class</span> Iter;                      <span class="comment">// 内部类，用来迭代 key-value</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>构造函数中出现了一个结构体 <code>BlockContents</code>，这个结构体是在 <code>table/format.h</code> 中定义的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> BlockContents &#123;</div><div class="line">  Slice data;           <span class="comment">// 存储数据的字符串，类似于block中的data_</span></div><div class="line">  <span class="keyword">bool</span> cachable;        <span class="comment">// True iff data can be cached ，不太懂这个变量，后续补充</span></div><div class="line">  <span class="keyword">bool</span> heap_allocated;  <span class="comment">// data是不是堆分配的内存，如果是的话就需要手动回收</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>block</code> 构造方法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// block.cc</span></div><div class="line">Block::Block(<span class="keyword">const</span> BlockContents&amp; contents)</div><div class="line">    : data_(contents.data.data()),</div><div class="line">      size_(contents.data.size()),</div><div class="line">      owned_(contents.heap_allocated) &#123;</div><div class="line">  <span class="keyword">if</span> (size_ &lt; <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)) &#123;       <span class="comment">//block中data_最后的restart_num就已经有4个字节的，如果size_还小于4个字节的话，只能说明这个块是坏的</span></div><div class="line">    size_ = <span class="number">0</span>;  <span class="comment">// Error marker</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123; </div><div class="line">    <span class="comment">// size_-sizeof(uint32_t)的意思是data_减去最后4个字节（最后4个字节记录着有多少个重启点），减去以后剩下部分大小就是数据大小加上重启点偏移数组大小</span></div><div class="line">    <span class="comment">// 如果减去的部分全部都是重启点偏移量数组，一个重启点偏移量占据4个字节，那么最多有(size_-sizeof(uint32_t)) / sizeof(uint32_t)个重启点</span></div><div class="line">    <span class="keyword">size_t</span> max_restarts_allowed = (size_-<span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)) / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</div><div class="line">    <span class="comment">// block中存储的重启点比最大重启点数还大，只能说明这个块有问题</span></div><div class="line">    <span class="comment">// 是不是感觉这个地方的写法很怪，我对比了一下leveldb初版中在此处的代码，发现之前不是这么写的，我怀疑是这个地方出现过问题，所以改成这样的</span></div><div class="line">    <span class="keyword">if</span> (NumRestarts() &gt; max_restarts_allowed) &#123;</div><div class="line">      <span class="comment">// The size is too small for NumRestarts()</span></div><div class="line">      size_ = <span class="number">0</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 第一个restart point在data_中的偏移量就很好计算了，总大小减去重启点偏移数组大小，再减去重启点个数占据的大小</span></div><div class="line">      restart_offset_ = size_ - (<span class="number">1</span> + NumRestarts()) * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>block</code> 构造方法说完，这里仅仅是 <code>block</code> 的结构，真正来来操作这个结构的类是 <code>blockbuilder</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// blockbuilder.h</span></div><div class="line"><span class="keyword">class</span> BlockBuilder &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">BlockBuilder</span><span class="params">(<span class="keyword">const</span> Options* options)</span></span>;</div><div class="line">  <span class="comment">// 重置block</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span></span>;</div><div class="line">  <span class="comment">// 往block中添加一个key-value</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span></span>;</div><div class="line">  <span class="comment">// block的大小已经超过限制后的操作</span></div><div class="line">  <span class="function">Slice <span class="title">Finish</span><span class="params">()</span></span>;</div><div class="line">  <span class="comment">// 估算出当前block的大小</span></div><div class="line">  <span class="keyword">size_t</span> CurrentSizeEstimate() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> buffer_.empty();</div><div class="line">  &#125;</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> Options*        options_;     <span class="comment">// leveldb的一些配置，比如block的大小等等</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>           buffer_;      <span class="comment">// Destination buffer</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint32_t</span>&gt; restarts_;    <span class="comment">// 记录重启点偏移量的数组</span></div><div class="line">  <span class="keyword">int</span>                   counter_;     <span class="comment">// 计数器，用于每16个key-value，就要开始记录一个完整的key</span></div><div class="line">  <span class="keyword">bool</span>                  finished_;    <span class="comment">// Has Finish() been called?</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>           last_key_;    <span class="comment">// 记录最后一个key，用于压缩前缀用</span></div><div class="line"></div><div class="line">  <span class="comment">// No copying allowed</span></div><div class="line">  BlockBuilder(<span class="keyword">const</span> BlockBuilder&amp;);</div><div class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> BlockBuilder&amp;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">&#125;  <span class="comment">// namespace leveldb</span></div></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line">BlockBuilder::BlockBuilder(<span class="keyword">const</span> Options* options)</div><div class="line">    : options_(options),</div><div class="line">      restarts_(),</div><div class="line">      counter_(<span class="number">0</span>),</div><div class="line">      finished_(<span class="literal">false</span>) &#123;</div><div class="line">  assert(options-&gt;block_restart_interval &gt;= <span class="number">1</span>);</div><div class="line">  restarts_.push_back(<span class="number">0</span>);       <span class="comment">// 第一个重启点就是第一个key，偏移量就是 0</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 重置就和构造方法差不多了</span></div><div class="line"><span class="keyword">void</span> BlockBuilder::Reset() &#123;</div><div class="line">  buffer_.clear();</div><div class="line">  restarts_.clear();</div><div class="line">  restarts_.push_back(<span class="number">0</span>);       <span class="comment">// First restart point is at offset 0</span></div><div class="line">  counter_ = <span class="number">0</span>;</div><div class="line">  finished_ = <span class="literal">false</span>;</div><div class="line">  last_key_.clear();</div><div class="line">&#125;</div><div class="line"><span class="comment">// buffer_中存储的是key-value，加上重启点偏移数组大小，再加上重启点个数大小，就是block估算的大小</span></div><div class="line"><span class="keyword">size_t</span> BlockBuilder::CurrentSizeEstimate() <span class="keyword">const</span> &#123;</div><div class="line">  <span class="keyword">return</span> (buffer_.size() +                        <span class="comment">// Raw data buffer</span></div><div class="line">          restarts_.size() * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>) +   <span class="comment">// Restart array</span></div><div class="line">          <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));                      <span class="comment">// Restart array length</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 划重点</span></div><div class="line"><span class="keyword">void</span> BlockBuilder::Add(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value) &#123;</div><div class="line">  <span class="function">Slice <span class="title">last_key_piece</span><span class="params">(last_key_)</span></span>;</div><div class="line">  assert(!finished_);</div><div class="line">  <span class="comment">// options_-&gt;block_restart_interval 默认为16，counter_如果大于16，那就说明异常了</span></div><div class="line">  assert(counter_ &lt;= options_-&gt;block_restart_interval);</div><div class="line">  <span class="comment">// buffer_为空或添加的key比上一个key小都会异常（顺序存储）</span></div><div class="line">  assert(buffer_.empty() <span class="comment">// No values yet?</span></div><div class="line">         || options_-&gt;comparator-&gt;Compare(key, last_key_piece) &gt; <span class="number">0</span>);</div><div class="line">  <span class="keyword">size_t</span> shared = <span class="number">0</span>; <span class="comment">// key中相同部分大小默认为0</span></div><div class="line">  <span class="comment">// 当计数器没有达到16时，说明没来到下一个重启点</span></div><div class="line">  <span class="keyword">if</span> (counter_ &lt; options_-&gt;block_restart_interval) &#123;</div><div class="line">    <span class="comment">// See how much sharing to do with previous string</span></div><div class="line">    <span class="comment">// 没有到下一个重启点话就可以压缩了，首先得到两个的最小长度</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> min_length = <span class="built_in">std</span>::min(last_key_piece.size(), key.size());</div><div class="line">    <span class="comment">// 得到相同部分大小</span></div><div class="line">    <span class="keyword">while</span> ((shared &lt; min_length) &amp;&amp; (last_key_piece[shared] == key[shared])) &#123;</div><div class="line">      shared++;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 到了新的重启点</span></div><div class="line">    <span class="comment">// Restart compression</span></div><div class="line">    <span class="comment">// 先在重启点偏移量数组中记录当前buffer_的大小，也就是偏移量（填坑2），然后重新计数</span></div><div class="line">    restarts_.push_back(buffer_.size());</div><div class="line">    counter_ = <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 得到key中不同部分的长度，如果是新的重启点的话shared是0，不同部分就是整个key的长度</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> non_shared = key.size() - shared;</div><div class="line"></div><div class="line">  <span class="comment">// Add "&lt;shared&gt;&lt;non_shared&gt;&lt;value_size&gt;" to buffer_</span></div><div class="line">  <span class="comment">// 无论是shard还是non_shared一般都不会很大，大部分情况下用一个字节就可以存储，</span></div><div class="line">  <span class="comment">// 而我们在定义的时候用的是size_t，直接将size_t放在buffer中，大部分情况下会浪费多个字节</span></div><div class="line">  <span class="comment">// 这里就用到了coding中的编码算法，具体分析请看前面coding类中的解析</span></div><div class="line">  <span class="comment">// 对照前文中讲到的格式分析</span></div><div class="line">  <span class="comment">// [key中相同部分大小][key中不同部分大小][value大小][key中不同部分值][value值]</span></div><div class="line">  PutVarint32(&amp;buffer_, shared);</div><div class="line">  PutVarint32(&amp;buffer_, non_shared);</div><div class="line">  PutVarint32(&amp;buffer_, value.size());</div><div class="line"></div><div class="line">  <span class="comment">// Add string delta to buffer_ followed by value</span></div><div class="line">  buffer_.append(key.data() + shared, non_shared);</div><div class="line">  buffer_.append(value.data(), value.size());</div><div class="line"> </div><div class="line">  <span class="comment">/*</span></div><div class="line">     这个地方有点意思，为啥不直接将key赋值给last_key_，这让我纳闷的很久，隐约可以看出是为了考虑效率？</div><div class="line">     我把自己的测试结果讲解一下，如有不对还请大家指出</div><div class="line">     last_key_是string类型，string中有两个成员变量，size和capacity，size表示当前string的长度是多少，capacity是string真实容量</div><div class="line">     如果我们直接赋值的话string会先将之前存储的数据释放，然后调用隐式构造为last_key_重新分配空间，效率低</div><div class="line">     如果我们调用resize的话，last_key_仅仅是将shared后面的字节截掉，capacity不会发生改变，也不会重新分配空间</div><div class="line">     再将non_shared部分添加到last_key_中，最后的效果一样，但是效率却千差万别</div><div class="line">  */ </div><div class="line">  last_key_.resize(shared);</div><div class="line">  last_key_.append(key.data() + shared, non_shared);</div><div class="line">  assert(Slice(last_key_) == key);</div><div class="line">  counter_++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// block的大小大于阈值后就会调用finish，就是将重启点偏移数组和重启点个数放到buffer中</span></div><div class="line">Slice BlockBuilder::Finish() &#123;</div><div class="line">  <span class="comment">// Append restart array</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; restarts_.size(); i++) &#123;</div><div class="line">    PutFixed32(&amp;buffer_, restarts_[i]);</div><div class="line">  &#125;</div><div class="line">  PutFixed32(&amp;buffer_, restarts_.size());</div><div class="line">  finished_ = <span class="literal">true</span>;</div><div class="line">  <span class="keyword">return</span> Slice(buffer_);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>【作者：antonyxu   <a href="https://antonyxux.github.io/】">https://antonyxux.github.io/】</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://antonyxux.github.io/2017/05/30/leveldb-1/" data-id="cj3j1juaw0000e5x8mrknpujb" class="article-share-link">分享</a><div class="tags"><a href="/tags/leveldb/">leveldb</a><a href="/tags/C/">C++</a></div><div class="post-nav"><a href="/2017/06/01/leveldb-2/" class="pre">Leveldb源码解析第二篇【Meta Block】</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://antonyxux.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Leveldb源码解析/">Leveldb源码解析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/leveldb/" style="font-size: 15px;">leveldb</a> <a href="/tags/C/" style="font-size: 15px;">C++</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/06/04/leveldb-4/">Leveldb源码解析第四篇【table添加key的流程】</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/02/leveldb-3/">Leveldb源码解析第三篇【Table 收尾】</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/01/leveldb-2/">Leveldb源码解析第二篇【Meta Block】</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/30/leveldb-1/">Leveldb源码解析第一篇【Data Block】</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://antonyxux.github.io/" title="链接出租" target="_blank">链接出租</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">AntonyX.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>